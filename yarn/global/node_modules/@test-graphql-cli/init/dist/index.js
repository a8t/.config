"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const inquirer_1 = require("inquirer");
const path_1 = require("path");
const promise_1 = tslib_1.__importDefault(require("simple-git/promise"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const fs_extra_1 = require("fs-extra");
const js_yaml_1 = require("js-yaml");
const rimraf_1 = tslib_1.__importDefault(require("rimraf"));
const cross_fetch_1 = tslib_1.__importDefault(require("cross-fetch"));
const ora_1 = tslib_1.__importDefault(require("ora"));
const search_codegen_config_1 = require("./search-codegen-config");
const fullname_1 = tslib_1.__importDefault(require("fullname"));
const latest_version_1 = tslib_1.__importDefault(require("latest-version"));
const tmp_1 = tslib_1.__importDefault(require("tmp"));
async function askForEnum(options) {
    let choices;
    const enumValues = Object.values(options.enum);
    if (options.ignoreList) {
        choices = enumValues.filter(enumValue => !options.ignoreList.includes(enumValue));
    }
    else {
        choices = enumValues;
    }
    const { answer } = await inquirer_1.prompt([
        {
            type: 'list',
            name: 'answer',
            message: options.message,
            choices,
            default: options.defaultValue,
        }
    ]);
    return answer;
}
var InitializationType;
(function (InitializationType) {
    InitializationType["FromScratch"] = "I want to create a new project from a GraphQL CLI Project Template.";
    InitializationType["ExistingOpenAPI"] = "I have an existing project using OpenAPI/Swagger Schema Definition.";
    InitializationType["ExistingGraphQL"] = "I have an existing project using GraphQL and want to add GraphQL CLI (run from project root).";
})(InitializationType || (InitializationType = {}));
var ProjectType;
(function (ProjectType) {
    ProjectType["FrontendOnly"] = "Frontend only";
    ProjectType["BackendOnly"] = "Backend only";
    ProjectType["FullStack"] = "Full Stack";
})(ProjectType || (ProjectType = {}));
var FrontendType;
(function (FrontendType) {
    FrontendType["TSReactApollo"] = "TypeScript React Apollo";
    FrontendType["ApolloAngular"] = "Apollo Angular";
    FrontendType["StencilApollo"] = "Stencil Apollo";
    FrontendType["TSUrql"] = "TypeScript Urql";
    FrontendType["GraphQLRequest"] = "GraphQL Request";
    FrontendType["ApolloAndroid"] = "Apollo Android";
    FrontendType["Other"] = "Other";
})(FrontendType || (FrontendType = {}));
var BackendType;
(function (BackendType) {
    BackendType["TS"] = "TypeScript";
    BackendType["Java"] = "Java";
    BackendType["Kotlin"] = "Kotlin";
    BackendType["Other"] = "Other";
})(BackendType || (BackendType = {}));
exports.plugin = {
    init({ program, reportError }) {
        program.
            command('init')
            .option('--projectName', 'Project name')
            .option('--templateName', 'Name of the predefined template')
            .option('--templateUrl', 'GitHub URL of the template. For example (http://github.com/ardatan/graphql-cli-example)')
            .action(async ({ projectName, templateName, templateUrl }) => {
            try {
                let graphqlConfig = {
                    extensions: {}
                };
                let projectPath = process.cwd();
                let projectType;
                if (!projectType) {
                    projectType = await askForEnum({
                        enum: ProjectType,
                        message: 'What is the type of the project?',
                        defaultValue: ProjectType.FullStack
                    });
                }
                const initializationType = await askForEnum({
                    enum: InitializationType,
                    message: 'Select the best option for you',
                    defaultValue: InitializationType.FromScratch,
                    ignoreList: projectType === ProjectType.FrontendOnly ? [InitializationType.ExistingOpenAPI] : [],
                });
                let npmPackages = new Set();
                npmPackages.add('graphql-cli');
                if (initializationType === InitializationType.ExistingGraphQL) {
                    if (fs_extra_1.existsSync(path_1.join(projectPath, 'package.json'))) {
                        const { default: packageJson } = await Promise.resolve().then(() => tslib_1.__importStar(require(path_1.join(projectPath, 'package.json'))));
                        projectName = packageJson.name;
                    }
                    const result = await search_codegen_config_1.searchCodegenConfig(projectPath);
                    if (result && !result.isEmpty) {
                        const codegenFilePath = result.filepath;
                        const { willBeMerged } = await inquirer_1.prompt([
                            {
                                type: 'confirm',
                                name: 'willBeMerged',
                                message: `GraphQL Code Generator configuration has been detected in ${codegenFilePath}.\n Do you want to use the same configuration with GraphQL CLI?`,
                                default: true,
                            }
                        ]);
                        if (willBeMerged) {
                            npmPackages.add('@test-graphql-cli/codegen');
                            const codegenConfig = result.config;
                            graphqlConfig.extensions.codegen = {
                                generates: {}
                            };
                            for (const key in codegenConfig) {
                                if (key === 'schema') {
                                    graphqlConfig.schema = codegenConfig.schema;
                                }
                                else if (key === 'documents') {
                                    graphqlConfig.documents = codegenConfig.documents;
                                }
                                else {
                                    graphqlConfig.extensions.codegen[key] = codegenConfig[key];
                                }
                            }
                            const removeOldCodegenConfigSpinner = ora_1.default('Removing old GraphQL Codegen configuration file').start();
                            rimraf_1.default.sync(result.filepath);
                            removeOldCodegenConfigSpinner.succeed();
                        }
                    }
                }
                if (initializationType === InitializationType.FromScratch) {
                    if (!projectName) {
                        const { projectName: enteredName } = await inquirer_1.prompt([
                            {
                                type: 'input',
                                name: 'projectName',
                                message: 'What is the name of the project?',
                                default: 'my-graphql-project'
                            }
                        ]);
                        projectName = enteredName;
                        projectPath = path_1.join(process.cwd(), projectName);
                    }
                    if (!templateName) {
                        const downloadingTemplateList = ora_1.default('Loading template list...').start();
                        const templateMap = await cross_fetch_1.default('https://raw.githubusercontent.com/Urigo/graphql-cli/master/templates.json').then(res => res.json());
                        downloadingTemplateList.succeed();
                        const templateNames = Object.keys(templateMap).filter(templateName => templateMap[templateName].projectType === projectType);
                        const { templateName: enteredTemplateName } = await inquirer_1.prompt([
                            {
                                type: 'list',
                                name: 'templateName',
                                message: `Which template do you want to start with your new ${projectType} project?`,
                                choices: [
                                    ...templateNames,
                                    'Other Template'
                                ],
                            }
                        ]);
                        let subDirPath = '/';
                        if (enteredTemplateName === 'Other Template') {
                            const { templateUrl: enteredTemplateUrl } = await inquirer_1.prompt([
                                {
                                    type: 'input',
                                    name: 'templateUrl',
                                    message: 'Enter Git URL of the template. For example (https://github.com/ardatan/graphql-cli-fullstack-template)'
                                }
                            ]);
                            templateUrl = enteredTemplateUrl;
                        }
                        else {
                            const selectedTemplate = templateMap[enteredTemplateName];
                            templateUrl = selectedTemplate.repository;
                            projectType = selectedTemplate.projectType;
                            if (selectedTemplate.path) {
                                subDirPath = selectedTemplate.path;
                            }
                        }
                        const cloningSpinner = ora_1.default(`Cloning template repository from ${templateUrl}...`).start();
                        const git = promise_1.default().silent(true);
                        const { name: tmpDir, removeCallback } = tmp_1.default.dirSync();
                        await git.clone(templateUrl, tmpDir);
                        rimraf_1.default.sync(path_1.join(tmpDir, '.git'));
                        fs_extra_1.moveSync(path_1.join(tmpDir, subDirPath), projectPath);
                        removeCallback();
                        cloningSpinner.stop();
                    }
                }
                const graphqlConfigPath = path_1.join(projectPath, '.graphqlrc.yml');
                try {
                    if (fs_extra_1.existsSync(graphqlConfigPath)) {
                        graphqlConfig = js_yaml_1.safeLoad(fs_extra_1.readFileSync(graphqlConfigPath, 'utf8'));
                    }
                }
                catch (e) {
                    console.warn(`Existing GraphQL Config file looks broken! Skipping...`);
                }
                if (projectType !== ProjectType.FrontendOnly && !graphqlConfig.extensions.generate) {
                    const { isBackendGenerationAsked } = await inquirer_1.prompt([
                        {
                            type: 'confirm',
                            name: 'isBackendGenerationAsked',
                            default: false,
                            message: 'Do you want to generate the backend code using a data model?',
                        }
                    ]);
                    if (isBackendGenerationAsked) {
                        graphqlConfig.extensions.generate = {};
                    }
                }
                if (graphqlConfig.extensions.generate && !graphqlConfig.extensions.generate.folders) {
                    const { model, resolvers, schema, } = await inquirer_1.prompt([
                        {
                            type: 'input',
                            name: 'model',
                            message: 'Where are you going to store your data models?',
                            default: './model'
                        },
                        {
                            type: 'input',
                            name: 'resolvers',
                            message: 'Where are you going to store your resolvers?',
                            default: './server/src/resolvers'
                        },
                        {
                            type: 'input',
                            name: 'schema',
                            message: 'Where are you going to store your schema files?',
                            default: './server/src/schema'
                        }
                    ]);
                    graphqlConfig.extensions.generate.folders = {
                        model,
                        resolvers,
                        schema,
                    };
                }
                ;
                if (initializationType === InitializationType.ExistingOpenAPI) {
                    const { openApiPath } = await inquirer_1.prompt([
                        {
                            type: 'input',
                            name: 'openApiPath',
                            message: 'Enter your OpenAPI schema path',
                            default: './swagger.json'
                        }
                    ]);
                    const processingOpenAPISpinner = ora_1.default(`Processing OpenAPI definition: ${openApiPath}`).start();
                    const schemaText = fs_extra_1.readFileSync(`${openApiPath}`, 'utf8');
                    let parsedObject;
                    if (openApiPath.endsWith('yaml') || openApiPath.endsWith('yml')) {
                        parsedObject = js_yaml_1.safeLoad(schemaText);
                    }
                    else {
                        parsedObject = JSON.parse(schemaText);
                    }
                    const datamodelPath = `${graphqlConfig.extensions.generate.model}/datamodel.graphql`;
                    try {
                        const { createGraphQLSchema } = await Promise.resolve().then(() => tslib_1.__importStar(require('openapi-to-graphql')));
                        let { schema } = await createGraphQLSchema(parsedObject, {
                            strict: true,
                            fillEmptyResponses: true,
                            equivalentToMessages: false,
                        });
                        const { printSchema } = await Promise.resolve().then(() => tslib_1.__importStar(require('graphql')));
                        const schemaString = printSchema(schema);
                        await fs_extra_1.ensureFile(datamodelPath);
                        fs_extra_1.writeFileSync(datamodelPath, schemaString);
                        processingOpenAPISpinner.succeed();
                    }
                    catch (err) {
                        processingOpenAPISpinner.fail(`Failed to process OpenAPI definition: ${datamodelPath}. Error: ${err}`);
                    }
                }
                if (!graphqlConfig.schema) {
                    const { schema } = await inquirer_1.prompt([
                        {
                            type: 'input',
                            name: 'schema',
                            message: 'Where is your schema?',
                            default: './schema.graphql',
                        }
                    ]);
                    if (schema.endsWith('.ts')) {
                        graphqlConfig.schema = {
                            [schema]: {
                                require: 'ts-node/register',
                            }
                        };
                    }
                    else {
                        graphqlConfig.schema = schema;
                    }
                }
                if (projectType === ProjectType.FullStack && graphqlConfig.extensions.generate && !graphqlConfig.extensions.generate.folders.client) {
                    const { client } = await inquirer_1.prompt([
                        {
                            type: 'input',
                            name: 'client',
                            message: 'Where do you want to store your GraphQL operation documents?',
                            default: './client/graphql'
                        }
                    ]);
                    graphqlConfig.extensions.generate.folders.client = client;
                }
                if (!graphqlConfig.documents && (projectType === ProjectType.FullStack || projectType === ProjectType.FrontendOnly)) {
                    const { documents } = await inquirer_1.prompt([
                        {
                            type: 'input',
                            name: 'documents',
                            message: 'Where are your operation documents?'
                        }
                    ]);
                    graphqlConfig.documents = documents;
                }
                if (!graphqlConfig.extensions.codegen) {
                    const { isCodegenAsked } = await inquirer_1.prompt([
                        {
                            type: 'confirm',
                            name: 'isCodegenAsked',
                            message: 'Do you want to use GraphQL Code Generator?',
                            default: true,
                        }
                    ]);
                    if (isCodegenAsked) {
                        npmPackages.add('@test-graphql-cli/codegen');
                        graphqlConfig.extensions.codegen = {};
                        let codegenPlugins = new Set();
                        if (projectType === ProjectType.FullStack || projectType === ProjectType.BackendOnly) {
                            const backendType = await askForEnum({
                                enum: BackendType,
                                message: 'What type of backend do you use?',
                                defaultValue: BackendType.TS
                            });
                            switch (backendType) {
                                case BackendType.TS:
                                    codegenPlugins.add('typescript');
                                    codegenPlugins.add('typescript-resolvers');
                                    break;
                                case BackendType.Java:
                                    codegenPlugins.add('java');
                                    codegenPlugins.add('java-resolvers');
                                    break;
                                case BackendType.Kotlin:
                                    codegenPlugins.add('java');
                                    codegenPlugins.add('java-kotlin');
                                    break;
                            }
                            const { backendGeneratedFile } = await inquirer_1.prompt([
                                {
                                    type: 'input',
                                    name: 'backendGeneratedFile',
                                    message: 'Where do you want to have generated backend code?',
                                    default: './generated-backend.ts',
                                }
                            ]);
                            graphqlConfig.extensions.codegen.generates[backendGeneratedFile] = {
                                plugins: [...codegenPlugins],
                            };
                        }
                        if (projectType === ProjectType.FullStack || projectType === ProjectType.FrontendOnly) {
                            const frontendType = await askForEnum({
                                enum: FrontendType,
                                message: 'What type of frontend do you use?',
                                defaultValue: FrontendType.TSReactApollo
                            });
                            switch (frontendType) {
                                case FrontendType.TSReactApollo:
                                    codegenPlugins.add('typescript');
                                    codegenPlugins.add('typescript-react-apollo');
                                    break;
                                case FrontendType.ApolloAngular:
                                    codegenPlugins.add('typescript');
                                    codegenPlugins.add('typescript-apollo-angular');
                                    break;
                                case FrontendType.StencilApollo:
                                    codegenPlugins.add('typescript');
                                    codegenPlugins.add('typescript-stencil-apollo');
                                    break;
                                case FrontendType.TSUrql:
                                    codegenPlugins.add('typescript');
                                    codegenPlugins.add('typescript-urql');
                                    break;
                                case FrontendType.GraphQLRequest:
                                    codegenPlugins.add('typescript');
                                    codegenPlugins.add('typescript-graphql-request');
                                    break;
                                case FrontendType.ApolloAndroid:
                                    codegenPlugins.add('java-apollo-android');
                                    break;
                            }
                            const { frontendGeneratedFile } = await inquirer_1.prompt([
                                {
                                    type: 'input',
                                    name: 'frontendGeneratedFile',
                                    message: 'Where do you want to have generated frontend code?',
                                    default: './generated-frontend.ts',
                                }
                            ]);
                            graphqlConfig.extensions.codegen.generates[frontendGeneratedFile] = {
                                plugins: [...codegenPlugins],
                            };
                        }
                        for (const codegenPlugin of codegenPlugins) {
                            npmPackages.add('@graphql-codegen/' + codegenPlugin);
                        }
                    }
                }
                if (projectType === ProjectType.FullStack || projectType === ProjectType.FrontendOnly) {
                    const { isFrontendInspectorAsked } = await inquirer_1.prompt([
                        {
                            type: 'confirm',
                            name: 'isFrontendInspectorAsked',
                            message: 'Do you want to have GraphQL Inspector tools for your frontend?',
                            default: true,
                        }
                    ]);
                    if (isFrontendInspectorAsked) {
                        npmPackages.add('@test-graphql-cli/coverage');
                        npmPackages.add('@test-graphql-cli/validate');
                    }
                }
                if (projectType === ProjectType.FullStack || projectType === ProjectType.BackendOnly) {
                    const { isBackendInspectorAsked } = await inquirer_1.prompt([
                        {
                            type: 'confirm',
                            name: 'isBackendInspectorAsked',
                            message: 'Do you want to have GraphQL Inspector tools for your backend?',
                            default: true,
                        }
                    ]);
                    if (isBackendInspectorAsked) {
                        npmPackages.add('@test-graphql-cli/diff');
                        npmPackages.add('@test-graphql-cli/serve');
                        npmPackages.add('@test-graphql-cli/similar');
                    }
                }
                const configPath = path_1.join(projectPath, '.graphqlrc.yml');
                await fs_extra_1.ensureFile(configPath);
                fs_extra_1.writeFileSync(configPath, js_yaml_1.safeDump(graphqlConfig, {
                    sortKeys: (a, b) => {
                        if (a === 'schema') {
                            return -1;
                        }
                        else if (b === 'schema') {
                            return 1;
                        }
                        else if (a === 'documents') {
                            return -1;
                        }
                        else if (b === 'documents') {
                            return 1;
                        }
                        else if (a === 'extensions') {
                            return 1;
                        }
                        else if (b === 'extensions') {
                            return -1;
                        }
                        else {
                            return a.localeCompare(b);
                        }
                    }
                }));
                let packageJson = {};
                try {
                    const importedPackageJson = await Promise.resolve().then(() => tslib_1.__importStar(require(path_1.join(projectPath, 'package.json'))));
                    packageJson = importedPackageJson.default || importedPackageJson || {};
                }
                catch (err) { }
                if (InitializationType.FromScratch) {
                    packageJson.private = true;
                    packageJson.name = projectName;
                    const name = await fullname_1.default();
                    if (name) {
                        packageJson.author = {
                            name,
                        };
                    }
                }
                packageJson.devDependencies = packageJson.devDependencies || {};
                const graphqlCliPackageJsonModule = require('graphql-cli/package.json');
                const graphqlCliPackageJson = graphqlCliPackageJsonModule.default || graphqlCliPackageJsonModule;
                for (const npmDependency of npmPackages) {
                    if (!(npmDependency in packageJson.devDependencies)) {
                        packageJson.devDependencies[npmDependency] = await latest_version_1.default(npmDependency);
                    }
                }
                for (const devDependency in packageJson.devDependencies) {
                    if (devDependency.startsWith('@graphql-cli') || devDependency === 'graphql-cli') {
                        packageJson.devDependencies[devDependency] = graphqlCliPackageJson.version;
                    }
                }
                await fs_extra_1.ensureFile(path_1.join(projectPath, 'package.json'));
                fs_extra_1.writeFileSync(path_1.join(projectPath, 'package.json'), JSON.stringify(packageJson, null, 2));
                console.info(`🚀  GraphQL CLI project successfully initialized:\n` +
                    `${projectPath}\n` +
                    `Next Steps:\n` +
                    `- Change directory to the project folder - ${chalk_1.default.cyan(`cd ${projectPath}`)}\n` +
                    `- Run ${chalk_1.default.cyan(`yarn install`)} to install dependencies\n` +
                    (initializationType !== InitializationType.ExistingGraphQL ?
                        `- ${chalk_1.default.cyan(`(Optional)`)} Initialize your git repo. ${chalk_1.default.cyan(`git init`)}.\n` +
                            `- Follow the instructions in README.md to continue...\n`
                        : ''));
                process.exit(0);
            }
            catch (e) {
                reportError(e);
            }
        });
    }
};
//# sourceMappingURL=index.js.map